// Bindings generated by `windows-bindgen` 0.53.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]
::windows_core::imp::com_interface!(
    IBlockScanner,
    IBlockScanner_Vtbl,
    0x2f4f16f0_fd77_52be_b656_cdde21df5f41
);
#[repr(C)]
pub struct IBlockScanner_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub Scan: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub ScanAsync: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    ICompiler,
    ICompiler_Vtbl,
    0x17b4fba5_281a_5264_a915_72a37dcb759d
);
::windows_core::imp::interface_hierarchy!(
    ICompiler,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
impl ICompiler {
    pub fn Compile(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).Compile)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileLiteral(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileLiteral)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileMultiLiteral<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiLiteral)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMulti<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMulti)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMultiEx<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiEx)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
}
impl ::windows_core::RuntimeType for ICompiler {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[repr(C)]
pub struct ICompiler_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub Compile: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        ::std::mem::MaybeUninit<::windows_core::HSTRING>,
        CompileFlags,
    ) -> ::windows_core::HRESULT,
    pub CompileLiteral: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        ::std::mem::MaybeUninit<::windows_core::HSTRING>,
        CompileFlags,
    ) -> ::windows_core::HRESULT,
    pub CompileMultiLiteral: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CompileMulti: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub CompileMultiEx: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    ICompiler2,
    ICompiler2_Vtbl,
    0xeab0deb4_d150_5b3a_98c3_bc7cd6d89f93
);
#[repr(C)]
pub struct ICompiler2_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub Platform: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub SetPlatform: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub SOMHorizon: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut SOMHorizonMode,
    ) -> ::windows_core::HRESULT,
    pub SetSOMHorizon: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        SOMHorizonMode,
    ) -> ::windows_core::HRESULT,
    pub Matched: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
        *mut ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::HRESULT,
    pub RemoveMatched: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    ICompilerFactory,
    ICompilerFactory_Vtbl,
    0x4ef01716_69e3_5aae_8745_ee344b6c53fd
);
#[repr(C)]
pub struct ICompilerFactory_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
}
::windows_core::imp::com_interface!(
    IDatabase,
    IDatabase_Vtbl,
    0x66f3fd77_47c4_5e7f_8933_79c5a6a6e531
);
::windows_core::imp::interface_hierarchy!(
    IDatabase,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
impl IDatabase {
    pub fn GetDatabaseInfo(&self) -> ::windows_core::Result<::windows_core::HSTRING> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseInfo)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetDatabaseSize(&self) -> ::windows_core::Result<u64> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseSize)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
}
impl ::windows_core::RuntimeType for IDatabase {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[repr(C)]
pub struct IDatabase_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub GetDatabaseInfo: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::std::mem::MaybeUninit<::windows_core::HSTRING>,
    ) -> ::windows_core::HRESULT,
    pub GetDatabaseSize:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u64) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IExpressionExtended,
    IExpressionExtended_Vtbl,
    0xebeebf60_6f50_5fce_944e_2c2fd5b06422
);
#[repr(C)]
pub struct IExpressionExtended_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub MinOffset:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u64) -> ::windows_core::HRESULT,
    pub SetMinOffset:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u64) -> ::windows_core::HRESULT,
    pub MaxOffset:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u64) -> ::windows_core::HRESULT,
    pub SetMaxOffset:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u64) -> ::windows_core::HRESULT,
    pub MinLength:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u64) -> ::windows_core::HRESULT,
    pub SetMinLength:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u64) -> ::windows_core::HRESULT,
    pub EditDistance:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub SetEditDistance:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u32) -> ::windows_core::HRESULT,
    pub HammingDistance:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub SetHammingDistance:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u32) -> ::windows_core::HRESULT,
    pub Reset: unsafe extern "system" fn(*mut ::core::ffi::c_void) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IExpressionInfo,
    IExpressionInfo_Vtbl,
    0xc4bddd27_cc19_5ec4_b108_10911054c8f3
);
#[repr(C)]
pub struct IExpressionInfo_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub MinWidth:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub SetMinWidth:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u32) -> ::windows_core::HRESULT,
    pub MaxWidth:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub SetMaxWidth:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u32) -> ::windows_core::HRESULT,
    pub IsUnorderedMatches:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut bool) -> ::windows_core::HRESULT,
    pub SetIsUnorderedMatches:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, bool) -> ::windows_core::HRESULT,
    pub IsMatchesAtEOD:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut bool) -> ::windows_core::HRESULT,
    pub SetIsMatchesAtEOD:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, bool) -> ::windows_core::HRESULT,
    pub IsMatchesOnlyAtEOD:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut bool) -> ::windows_core::HRESULT,
    pub SetIsMatchesOnlyAtEOD:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, bool) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IExpressionInfoFactory,
    IExpressionInfoFactory_Vtbl,
    0x918cfc11_16e1_582e_8435_c26cb4868fd9
);
#[repr(C)]
pub struct IExpressionInfoFactory_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        u32,
        u32,
        bool,
        bool,
        bool,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IMatchEventArgs,
    IMatchEventArgs_Vtbl,
    0x80c5933c_2f9d_534f_a1e2_04b99312c5ec
);
#[repr(C)]
pub struct IMatchEventArgs_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub From:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u64) -> ::windows_core::HRESULT,
    pub To:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u64) -> ::windows_core::HRESULT,
    pub Id:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub Flags:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub ReturnValue:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub SetReturnValue:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, u32) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IMatchEventArgsFactory,
    IMatchEventArgsFactory_Vtbl,
    0x062d3df0_e6f9_577b_8547_dd76085237fd
);
#[repr(C)]
pub struct IMatchEventArgsFactory_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        u64,
        u64,
        u32,
        u32,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IPattern,
    IPattern_Vtbl,
    0x3898e59b_d140_593d_9087_cb55a72c2246
);
#[repr(C)]
pub struct IPattern_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub Expression: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::std::mem::MaybeUninit<::windows_core::HSTRING>,
    ) -> ::windows_core::HRESULT,
    pub SetExpression: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        ::std::mem::MaybeUninit<::windows_core::HSTRING>,
    ) -> ::windows_core::HRESULT,
    pub Flags: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut CompileFlags,
    ) -> ::windows_core::HRESULT,
    pub SetFlags: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        CompileFlags,
    ) -> ::windows_core::HRESULT,
    pub Extended: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub SetExtended: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub Id:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, *mut u32) -> ::windows_core::HRESULT,
    pub SetId: unsafe extern "system" fn(*mut ::core::ffi::c_void, u32) -> ::windows_core::HRESULT,
    pub GetExpressionInfo: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IPatternFactory,
    IPatternFactory_Vtbl,
    0x9b5cd3c0_6599_516a_85a5_15d3d292187b
);
#[repr(C)]
pub struct IPatternFactory_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        ::std::mem::MaybeUninit<::windows_core::HSTRING>,
        CompileFlags,
        *mut ::core::ffi::c_void,
        u32,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IPlatformInfo,
    IPlatformInfo_Vtbl,
    0x0a988acc_e8d0_5126_9f44_21ce1253cfc7
);
#[repr(C)]
pub struct IPlatformInfo_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub Features: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut CPUFeatures,
    ) -> ::windows_core::HRESULT,
    pub SetFeatures:
        unsafe extern "system" fn(*mut ::core::ffi::c_void, CPUFeatures) -> ::windows_core::HRESULT,
    pub Tune: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut CompilerTune,
    ) -> ::windows_core::HRESULT,
    pub SetTune: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        CompilerTune,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IPlatformInfoFactory,
    IPlatformInfoFactory_Vtbl,
    0x0db63429_58ac_5f80_b543_c54455ef8595
);
#[repr(C)]
pub struct IPlatformInfoFactory_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        CPUFeatures,
        CompilerTune,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IPlatformInfoStatics,
    IPlatformInfoStatics_Vtbl,
    0xbf2cce91_f07f_5bf5_9b8c_339fa2835e23
);
#[repr(C)]
pub struct IPlatformInfoStatics_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub HostPlatformInfo: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    ISScanner,
    ISScanner_Vtbl,
    0x52904a10_802c_50a2_aefa_3a1f3606e4b4
);
#[repr(C)]
pub struct ISScanner_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub ScanNext: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub Matched: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
        *mut ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::HRESULT,
    pub RemoveMatched: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    ISScannerFactory,
    ISScannerFactory_Vtbl,
    0x79260994_ffc1_5c72_83df_d462f9b07a03
);
#[repr(C)]
pub struct ISScannerFactory_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    ISettingsStatics,
    ISettingsStatics_Vtbl,
    0x5d391716_1915_5bc3_9518_8401ec2ad98e
);
#[repr(C)]
pub struct ISettingsStatics_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub SetAllocator: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        ::std::mem::MaybeUninit<::windows_core::HSTRING>,
        ::std::mem::MaybeUninit<::windows_core::HSTRING>,
        ::std::mem::MaybeUninit<::windows_core::HSTRING>,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IStreamScanner,
    IStreamScanner_Vtbl,
    0x6be5a12a_4b05_563f_a338_a7e45da7f91e
);
#[repr(C)]
pub struct IStreamScanner_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub CreateScanner: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
::windows_core::imp::com_interface!(
    IVectorScanner,
    IVectorScanner_Vtbl,
    0x247d3ab6_88e7_58a5_a455_1808a95c69d4
);
#[repr(C)]
pub struct IVectorScanner_Vtbl {
    pub base__: ::windows_core::IInspectable_Vtbl,
    pub Scan: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
    pub ScanAsync: unsafe extern "system" fn(
        *mut ::core::ffi::c_void,
        *mut ::core::ffi::c_void,
        *mut *mut ::core::ffi::c_void,
    ) -> ::windows_core::HRESULT,
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct BlockScanner(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    BlockScanner,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
::windows_core::imp::required_hierarchy!(BlockScanner, ICompiler, IDatabase, Compiler);
impl BlockScanner {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            BlockScanner,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Scan<P0>(&self, buffer: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Storage::Streams::IBuffer>,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).Scan)(
                ::windows_core::Interface::as_raw(this),
                buffer.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn ScanAsync<P0>(
        &self,
        buffer: P0,
    ) -> ::windows_core::Result<::windows::Foundation::IAsyncAction>
    where
        P0: ::windows_core::IntoParam<::windows::Storage::Streams::IBuffer>,
    {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).ScanAsync)(
                ::windows_core::Interface::as_raw(this),
                buffer.into_param().abi(),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn Compile(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).Compile)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileLiteral(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileLiteral)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileMultiLiteral<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiLiteral)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMulti<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMulti)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMultiEx<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiEx)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn Platform(&self) -> ::windows_core::Result<PlatformInfo> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Platform)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetPlatform<P0>(&self, value: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<PlatformInfo>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).SetPlatform)(
                ::windows_core::Interface::as_raw(this),
                value.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn SOMHorizon(&self) -> ::windows_core::Result<SOMHorizonMode> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).SOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSOMHorizon(&self, value: SOMHorizonMode) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).SetSOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Matched<P0>(
        &self,
        handler: P0,
    ) -> ::windows_core::Result<::windows::Foundation::EventRegistrationToken>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::EventHandler<MatchEventArgs>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Matched)(
                ::windows_core::Interface::as_raw(this),
                handler.into_param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveMatched(
        &self,
        token: ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).RemoveMatched)(
                ::windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn GetDatabaseInfo(&self) -> ::windows_core::Result<::windows_core::HSTRING> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseInfo)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetDatabaseSize(&self) -> ::windows_core::Result<u64> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseSize)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
}
impl ::windows_core::RuntimeType for BlockScanner {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for BlockScanner {
    type Vtable = IBlockScanner_Vtbl;
    const IID: ::windows_core::GUID = <IBlockScanner as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for BlockScanner {
    const NAME: &'static str = "Hyperscan.BlockScanner";
}
unsafe impl ::core::marker::Send for BlockScanner {}
unsafe impl ::core::marker::Sync for BlockScanner {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct Compiler(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    Compiler,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
::windows_core::imp::required_hierarchy!(Compiler, ICompiler, IDatabase);
impl Compiler {
    pub fn Compile(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).Compile)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileLiteral(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileLiteral)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileMultiLiteral<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiLiteral)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMulti<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMulti)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMultiEx<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiEx)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn Platform(&self) -> ::windows_core::Result<PlatformInfo> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Platform)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetPlatform<P0>(&self, value: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<PlatformInfo>,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetPlatform)(
                ::windows_core::Interface::as_raw(this),
                value.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn SOMHorizon(&self) -> ::windows_core::Result<SOMHorizonMode> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).SOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSOMHorizon(&self, value: SOMHorizonMode) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetSOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Matched<P0>(
        &self,
        handler: P0,
    ) -> ::windows_core::Result<::windows::Foundation::EventRegistrationToken>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::EventHandler<MatchEventArgs>>,
    {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Matched)(
                ::windows_core::Interface::as_raw(this),
                handler.into_param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveMatched(
        &self,
        token: ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).RemoveMatched)(
                ::windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn GetDatabaseInfo(&self) -> ::windows_core::Result<::windows_core::HSTRING> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseInfo)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetDatabaseSize(&self) -> ::windows_core::Result<u64> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseSize)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
}
impl ::windows_core::RuntimeType for Compiler {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for Compiler {
    type Vtable = ICompiler2_Vtbl;
    const IID: ::windows_core::GUID = <ICompiler2 as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for Compiler {
    const NAME: &'static str = "Hyperscan.Compiler";
}
unsafe impl ::core::marker::Send for Compiler {}
unsafe impl ::core::marker::Sync for Compiler {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct ExpressionExtended(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    ExpressionExtended,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
impl ExpressionExtended {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            ExpressionExtended,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn MinOffset(&self) -> ::windows_core::Result<u64> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).MinOffset)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMinOffset(&self, value: u64) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetMinOffset)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn MaxOffset(&self) -> ::windows_core::Result<u64> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).MaxOffset)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMaxOffset(&self, value: u64) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetMaxOffset)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn MinLength(&self) -> ::windows_core::Result<u64> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).MinLength)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMinLength(&self, value: u64) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetMinLength)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn EditDistance(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).EditDistance)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetEditDistance(&self, value: u32) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetEditDistance)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn HammingDistance(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).HammingDistance)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetHammingDistance(&self, value: u32) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetHammingDistance)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Reset(&self) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).Reset)(::windows_core::Interface::as_raw(this))
                .ok()
        }
    }
}
impl ::windows_core::RuntimeType for ExpressionExtended {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for ExpressionExtended {
    type Vtable = IExpressionExtended_Vtbl;
    const IID: ::windows_core::GUID = <IExpressionExtended as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for ExpressionExtended {
    const NAME: &'static str = "Hyperscan.ExpressionExtended";
}
unsafe impl ::core::marker::Send for ExpressionExtended {}
unsafe impl ::core::marker::Sync for ExpressionExtended {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct ExpressionInfo(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    ExpressionInfo,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
impl ExpressionInfo {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            ExpressionInfo,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn MinWidth(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).MinWidth)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMinWidth(&self, value: u32) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetMinWidth)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn MaxWidth(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).MaxWidth)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMaxWidth(&self, value: u32) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetMaxWidth)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn IsUnorderedMatches(&self) -> ::windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).IsUnorderedMatches)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetIsUnorderedMatches(&self, value: bool) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetIsUnorderedMatches)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn IsMatchesAtEOD(&self) -> ::windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).IsMatchesAtEOD)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetIsMatchesAtEOD(&self, value: bool) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetIsMatchesAtEOD)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn IsMatchesOnlyAtEOD(&self) -> ::windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).IsMatchesOnlyAtEOD)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetIsMatchesOnlyAtEOD(&self, value: bool) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetIsMatchesOnlyAtEOD)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CreateInstance(
        minwidth: u32,
        maxwidth: u32,
        isunorderedmatches: bool,
        ismatchesateod: bool,
        ismatchesonlyateod: bool,
    ) -> ::windows_core::Result<ExpressionInfo> {
        Self::IExpressionInfoFactory(|this| unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).CreateInstance)(
                ::windows_core::Interface::as_raw(this),
                minwidth,
                maxwidth,
                isunorderedmatches,
                ismatchesateod,
                ismatchesonlyateod,
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        })
    }
    #[doc(hidden)]
    pub fn IExpressionInfoFactory<
        R,
        F: FnOnce(&IExpressionInfoFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<ExpressionInfo, IExpressionInfoFactory> =
            ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl ::windows_core::RuntimeType for ExpressionInfo {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for ExpressionInfo {
    type Vtable = IExpressionInfo_Vtbl;
    const IID: ::windows_core::GUID = <IExpressionInfo as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for ExpressionInfo {
    const NAME: &'static str = "Hyperscan.ExpressionInfo";
}
unsafe impl ::core::marker::Send for ExpressionInfo {}
unsafe impl ::core::marker::Sync for ExpressionInfo {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct MatchEventArgs(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    MatchEventArgs,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
impl MatchEventArgs {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            MatchEventArgs,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn From(&self) -> ::windows_core::Result<u64> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).From)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn To(&self) -> ::windows_core::Result<u64> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).To)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Id(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Id)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Flags(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Flags)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReturnValue(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).ReturnValue)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetReturnValue(&self, value: u32) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetReturnValue)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CreateInstance(
        from: u64,
        to: u64,
        id: u32,
        flags: u32,
    ) -> ::windows_core::Result<MatchEventArgs> {
        Self::IMatchEventArgsFactory(|this| unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).CreateInstance)(
                ::windows_core::Interface::as_raw(this),
                from,
                to,
                id,
                flags,
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        })
    }
    #[doc(hidden)]
    pub fn IMatchEventArgsFactory<
        R,
        F: FnOnce(&IMatchEventArgsFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<MatchEventArgs, IMatchEventArgsFactory> =
            ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl ::windows_core::RuntimeType for MatchEventArgs {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for MatchEventArgs {
    type Vtable = IMatchEventArgs_Vtbl;
    const IID: ::windows_core::GUID = <IMatchEventArgs as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for MatchEventArgs {
    const NAME: &'static str = "Hyperscan.MatchEventArgs";
}
unsafe impl ::core::marker::Send for MatchEventArgs {}
unsafe impl ::core::marker::Sync for MatchEventArgs {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct Pattern(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    Pattern,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
impl Pattern {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            Pattern,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Expression(&self) -> ::windows_core::Result<::windows_core::HSTRING> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Expression)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetExpression(&self, value: &::windows_core::HSTRING) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetExpression)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(value),
            )
            .ok()
        }
    }
    pub fn Flags(&self) -> ::windows_core::Result<CompileFlags> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Flags)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetFlags(&self, value: CompileFlags) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetFlags)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Extended(&self) -> ::windows_core::Result<ExpressionExtended> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Extended)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetExtended<P0>(&self, value: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<ExpressionExtended>,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetExtended)(
                ::windows_core::Interface::as_raw(this),
                value.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn Id(&self) -> ::windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Id)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetId(&self, value: u32) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetId)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GetExpressionInfo(&self) -> ::windows_core::Result<ExpressionInfo> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetExpressionInfo)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn CreateInstance<P0>(
        expression: &::windows_core::HSTRING,
        flags: CompileFlags,
        extended: P0,
        id: u32,
    ) -> ::windows_core::Result<Pattern>
    where
        P0: ::windows_core::IntoParam<ExpressionExtended>,
    {
        Self::IPatternFactory(|this| unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).CreateInstance)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(expression),
                flags,
                extended.into_param().abi(),
                id,
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        })
    }
    #[doc(hidden)]
    pub fn IPatternFactory<R, F: FnOnce(&IPatternFactory) -> ::windows_core::Result<R>>(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<Pattern, IPatternFactory> =
            ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl ::windows_core::RuntimeType for Pattern {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for Pattern {
    type Vtable = IPattern_Vtbl;
    const IID: ::windows_core::GUID = <IPattern as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for Pattern {
    const NAME: &'static str = "Hyperscan.Pattern";
}
unsafe impl ::core::marker::Send for Pattern {}
unsafe impl ::core::marker::Sync for Pattern {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct PlatformInfo(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    PlatformInfo,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
impl PlatformInfo {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            PlatformInfo,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Features(&self) -> ::windows_core::Result<CPUFeatures> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Features)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetFeatures(&self, value: CPUFeatures) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetFeatures)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Tune(&self) -> ::windows_core::Result<CompilerTune> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Tune)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetTune(&self, value: CompilerTune) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).SetTune)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CreateInstance(
        features: CPUFeatures,
        tune: CompilerTune,
    ) -> ::windows_core::Result<PlatformInfo> {
        Self::IPlatformInfoFactory(|this| unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).CreateInstance)(
                ::windows_core::Interface::as_raw(this),
                features,
                tune,
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        })
    }
    pub fn HostPlatformInfo() -> ::windows_core::Result<PlatformInfo> {
        Self::IPlatformInfoStatics(|this| unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).HostPlatformInfo)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        })
    }
    #[doc(hidden)]
    pub fn IPlatformInfoFactory<
        R,
        F: FnOnce(&IPlatformInfoFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<PlatformInfo, IPlatformInfoFactory> =
            ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    #[doc(hidden)]
    pub fn IPlatformInfoStatics<
        R,
        F: FnOnce(&IPlatformInfoStatics) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<PlatformInfo, IPlatformInfoStatics> =
            ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl ::windows_core::RuntimeType for PlatformInfo {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for PlatformInfo {
    type Vtable = IPlatformInfo_Vtbl;
    const IID: ::windows_core::GUID = <IPlatformInfo as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for PlatformInfo {
    const NAME: &'static str = "Hyperscan.PlatformInfo";
}
unsafe impl ::core::marker::Send for PlatformInfo {}
unsafe impl ::core::marker::Sync for PlatformInfo {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct SScanner(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    SScanner,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
::windows_core::imp::required_hierarchy!(SScanner, ::windows::Foundation::IClosable);
impl SScanner {
    pub fn Close(&self) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<::windows::Foundation::IClosable>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).Close)(::windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn ScanNext<P0>(&self, buffer: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Storage::Streams::IBuffer>,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).ScanNext)(
                ::windows_core::Interface::as_raw(this),
                buffer.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn Matched<P0>(
        &self,
        handler: P0,
    ) -> ::windows_core::Result<::windows::Foundation::EventRegistrationToken>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::EventHandler<MatchEventArgs>>,
    {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Matched)(
                ::windows_core::Interface::as_raw(this),
                handler.into_param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveMatched(
        &self,
        token: ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::Result<()> {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).RemoveMatched)(
                ::windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn CreateInstance<P0>(streamscanner: P0) -> ::windows_core::Result<SScanner>
    where
        P0: ::windows_core::IntoParam<StreamScanner>,
    {
        Self::ISScannerFactory(|this| unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).CreateInstance)(
                ::windows_core::Interface::as_raw(this),
                streamscanner.into_param().abi(),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        })
    }
    #[doc(hidden)]
    pub fn ISScannerFactory<R, F: FnOnce(&ISScannerFactory) -> ::windows_core::Result<R>>(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<SScanner, ISScannerFactory> =
            ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl ::windows_core::RuntimeType for SScanner {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for SScanner {
    type Vtable = ISScanner_Vtbl;
    const IID: ::windows_core::GUID = <ISScanner as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for SScanner {
    const NAME: &'static str = "Hyperscan.SScanner";
}
unsafe impl ::core::marker::Send for SScanner {}
unsafe impl ::core::marker::Sync for SScanner {}
pub struct Settings;
impl Settings {
    pub fn SetAllocator(
        modulename: &::windows_core::HSTRING,
        allocprocname: &::windows_core::HSTRING,
        freeprocname: &::windows_core::HSTRING,
    ) -> ::windows_core::Result<()> {
        Self::ISettingsStatics(|this| unsafe {
            (::windows_core::Interface::vtable(this).SetAllocator)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(modulename),
                ::core::mem::transmute_copy(allocprocname),
                ::core::mem::transmute_copy(freeprocname),
            )
            .ok()
        })
    }
    #[doc(hidden)]
    pub fn ISettingsStatics<R, F: FnOnce(&ISettingsStatics) -> ::windows_core::Result<R>>(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<Settings, ISettingsStatics> =
            ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl ::windows_core::RuntimeName for Settings {
    const NAME: &'static str = "Hyperscan.Settings";
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct StreamScanner(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    StreamScanner,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
::windows_core::imp::required_hierarchy!(StreamScanner, ICompiler, IDatabase, Compiler);
impl StreamScanner {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            StreamScanner,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Compile(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).Compile)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileLiteral(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileLiteral)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileMultiLiteral<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiLiteral)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMulti<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMulti)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMultiEx<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiEx)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn Platform(&self) -> ::windows_core::Result<PlatformInfo> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Platform)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetPlatform<P0>(&self, value: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<PlatformInfo>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).SetPlatform)(
                ::windows_core::Interface::as_raw(this),
                value.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn SOMHorizon(&self) -> ::windows_core::Result<SOMHorizonMode> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).SOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSOMHorizon(&self, value: SOMHorizonMode) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).SetSOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Matched<P0>(
        &self,
        handler: P0,
    ) -> ::windows_core::Result<::windows::Foundation::EventRegistrationToken>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::EventHandler<MatchEventArgs>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Matched)(
                ::windows_core::Interface::as_raw(this),
                handler.into_param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveMatched(
        &self,
        token: ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).RemoveMatched)(
                ::windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn GetDatabaseInfo(&self) -> ::windows_core::Result<::windows_core::HSTRING> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseInfo)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetDatabaseSize(&self) -> ::windows_core::Result<u64> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseSize)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn CreateScanner(&self) -> ::windows_core::Result<SScanner> {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).CreateScanner)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
}
impl ::windows_core::RuntimeType for StreamScanner {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for StreamScanner {
    type Vtable = IStreamScanner_Vtbl;
    const IID: ::windows_core::GUID = <IStreamScanner as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for StreamScanner {
    const NAME: &'static str = "Hyperscan.StreamScanner";
}
unsafe impl ::core::marker::Send for StreamScanner {}
unsafe impl ::core::marker::Sync for StreamScanner {}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone)]
pub struct VectorScanner(::windows_core::IUnknown);
::windows_core::imp::interface_hierarchy!(
    VectorScanner,
    ::windows_core::IUnknown,
    ::windows_core::IInspectable
);
::windows_core::imp::required_hierarchy!(VectorScanner, ICompiler, IDatabase, Compiler);
impl VectorScanner {
    pub fn new() -> ::windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&::windows_core::imp::IGenericFactory) -> ::windows_core::Result<R>,
    >(
        callback: F,
    ) -> ::windows_core::Result<R> {
        static SHARED: ::windows_core::imp::FactoryCache<
            VectorScanner,
            ::windows_core::imp::IGenericFactory,
        > = ::windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Compile(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).Compile)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileLiteral(
        &self,
        pattern: &::windows_core::HSTRING,
        flags: CompileFlags,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileLiteral)(
                ::windows_core::Interface::as_raw(this),
                ::core::mem::transmute_copy(pattern),
                flags,
            )
            .ok()
        }
    }
    pub fn CompileMultiLiteral<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiLiteral)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMulti<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMulti)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn CompileMultiEx<P0>(&self, patterns: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::Collections::IVectorView<Pattern>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).CompileMultiEx)(
                ::windows_core::Interface::as_raw(this),
                patterns.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn Platform(&self) -> ::windows_core::Result<PlatformInfo> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Platform)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetPlatform<P0>(&self, value: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<PlatformInfo>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).SetPlatform)(
                ::windows_core::Interface::as_raw(this),
                value.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn SOMHorizon(&self) -> ::windows_core::Result<SOMHorizonMode> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).SOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSOMHorizon(&self, value: SOMHorizonMode) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).SetSOMHorizon)(
                ::windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Matched<P0>(
        &self,
        handler: P0,
    ) -> ::windows_core::Result<::windows::Foundation::EventRegistrationToken>
    where
        P0: ::windows_core::IntoParam<::windows::Foundation::EventHandler<MatchEventArgs>>,
    {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).Matched)(
                ::windows_core::Interface::as_raw(this),
                handler.into_param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveMatched(
        &self,
        token: ::windows::Foundation::EventRegistrationToken,
    ) -> ::windows_core::Result<()> {
        let this = &::windows_core::Interface::cast::<ICompiler2>(self)?;
        unsafe {
            (::windows_core::Interface::vtable(this).RemoveMatched)(
                ::windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn GetDatabaseInfo(&self) -> ::windows_core::Result<::windows_core::HSTRING> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseInfo)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetDatabaseSize(&self) -> ::windows_core::Result<u64> {
        let this = &::windows_core::Interface::cast::<IDatabase>(self)?;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).GetDatabaseSize)(
                ::windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Scan<P0>(&self, buffers: P0) -> ::windows_core::Result<()>
    where
        P0: ::windows_core::IntoParam<
            ::windows::Foundation::Collections::IVectorView<::windows::Storage::Streams::IBuffer>,
        >,
    {
        let this = self;
        unsafe {
            (::windows_core::Interface::vtable(this).Scan)(
                ::windows_core::Interface::as_raw(this),
                buffers.into_param().abi(),
            )
            .ok()
        }
    }
    pub fn ScanAsync<P0>(
        &self,
        buffers: P0,
    ) -> ::windows_core::Result<::windows::Foundation::IAsyncAction>
    where
        P0: ::windows_core::IntoParam<
            ::windows::Foundation::Collections::IVectorView<::windows::Storage::Streams::IBuffer>,
        >,
    {
        let this = self;
        unsafe {
            let mut result__ = ::std::mem::zeroed();
            (::windows_core::Interface::vtable(this).ScanAsync)(
                ::windows_core::Interface::as_raw(this),
                buffers.into_param().abi(),
                &mut result__,
            )
            .and_then(|| ::windows_core::Type::from_abi(result__))
        }
    }
}
impl ::windows_core::RuntimeType for VectorScanner {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::for_class::<Self>();
}
unsafe impl ::windows_core::Interface for VectorScanner {
    type Vtable = IVectorScanner_Vtbl;
    const IID: ::windows_core::GUID = <IVectorScanner as ::windows_core::Interface>::IID;
}
impl ::windows_core::RuntimeName for VectorScanner {
    const NAME: &'static str = "Hyperscan.VectorScanner";
}
unsafe impl ::core::marker::Send for VectorScanner {}
unsafe impl ::core::marker::Sync for VectorScanner {}
#[repr(transparent)]
#[derive(
    ::core::cmp::PartialEq,
    ::core::cmp::Eq,
    ::core::marker::Copy,
    ::core::clone::Clone,
    ::core::default::Default,
)]
pub struct CPUFeatures(pub u32);
impl CPUFeatures {
    pub const GENERIC: Self = Self(0u32);
    pub const AVX2: Self = Self(4u32);
    pub const AVX512: Self = Self(8u32);
    pub const AVX512VBMI: Self = Self(16u32);
}
impl ::windows_core::TypeKind for CPUFeatures {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for CPUFeatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CPUFeatures").field(&self.0).finish()
    }
}
impl CPUFeatures {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for CPUFeatures {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for CPUFeatures {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for CPUFeatures {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for CPUFeatures {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for CPUFeatures {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::windows_core::RuntimeType for CPUFeatures {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::from_slice(b"enum(Hyperscan.CPUFeatures;u4)");
}
#[repr(transparent)]
#[derive(
    ::core::cmp::PartialEq,
    ::core::cmp::Eq,
    ::core::marker::Copy,
    ::core::clone::Clone,
    ::core::default::Default,
)]
pub struct CompileFlags(pub u32);
impl CompileFlags {
    pub const None: Self = Self(0u32);
    pub const Caseless: Self = Self(1u32);
    pub const DotAll: Self = Self(2u32);
    pub const Multiline: Self = Self(4u32);
    pub const SingleMatch: Self = Self(8u32);
    pub const AllowEmpty: Self = Self(16u32);
    pub const UTF8: Self = Self(32u32);
    pub const UCP: Self = Self(64u32);
    pub const PreFilter: Self = Self(128u32);
    pub const SOMLeftMost: Self = Self(256u32);
    pub const Combination: Self = Self(512u32);
    pub const Quiet: Self = Self(1024u32);
}
impl ::windows_core::TypeKind for CompileFlags {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for CompileFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CompileFlags").field(&self.0).finish()
    }
}
impl CompileFlags {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for CompileFlags {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for CompileFlags {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for CompileFlags {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for CompileFlags {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for CompileFlags {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::windows_core::RuntimeType for CompileFlags {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::from_slice(b"enum(Hyperscan.CompileFlags;u4)");
}
#[repr(transparent)]
#[derive(
    ::core::cmp::PartialEq,
    ::core::cmp::Eq,
    ::core::marker::Copy,
    ::core::clone::Clone,
    ::core::default::Default,
)]
pub struct CompileMode(pub i32);
impl CompileMode {
    pub const Block: Self = Self(1i32);
    pub const Stream: Self = Self(2i32);
    pub const Vectored: Self = Self(4i32);
}
impl ::windows_core::TypeKind for CompileMode {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for CompileMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CompileMode").field(&self.0).finish()
    }
}
impl ::windows_core::RuntimeType for CompileMode {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::from_slice(b"enum(Hyperscan.CompileMode;i4)");
}
#[repr(transparent)]
#[derive(
    ::core::cmp::PartialEq,
    ::core::cmp::Eq,
    ::core::marker::Copy,
    ::core::clone::Clone,
    ::core::default::Default,
)]
pub struct CompilerTune(pub i32);
impl CompilerTune {
    pub const GENERIC: Self = Self(0i32);
    pub const SNB: Self = Self(1i32);
    pub const IVB: Self = Self(2i32);
    pub const HSW: Self = Self(3i32);
    pub const SLM: Self = Self(4i32);
    pub const BDW: Self = Self(5i32);
    pub const SKL: Self = Self(6i32);
    pub const SKX: Self = Self(7i32);
    pub const GLM: Self = Self(8i32);
    pub const ICL: Self = Self(9i32);
    pub const ICX: Self = Self(10i32);
}
impl ::windows_core::TypeKind for CompilerTune {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for CompilerTune {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CompilerTune").field(&self.0).finish()
    }
}
impl ::windows_core::RuntimeType for CompilerTune {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::from_slice(b"enum(Hyperscan.CompilerTune;i4)");
}
#[repr(transparent)]
#[derive(
    ::core::cmp::PartialEq,
    ::core::cmp::Eq,
    ::core::marker::Copy,
    ::core::clone::Clone,
    ::core::default::Default,
)]
pub struct SOMHorizonMode(pub i32);
impl SOMHorizonMode {
    pub const SOMHorizonLarge: Self = Self(16777216i32);
    pub const SOMHorizonMedium: Self = Self(33554432i32);
    pub const SOMHorizonSmall: Self = Self(67108864i32);
}
impl ::windows_core::TypeKind for SOMHorizonMode {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SOMHorizonMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SOMHorizonMode").field(&self.0).finish()
    }
}
impl ::windows_core::RuntimeType for SOMHorizonMode {
    const SIGNATURE: ::windows_core::imp::ConstBuffer =
        ::windows_core::imp::ConstBuffer::from_slice(b"enum(Hyperscan.SOMHorizonMode;i4)");
}
